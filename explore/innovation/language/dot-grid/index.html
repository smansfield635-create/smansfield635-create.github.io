<!-- TNT — /explore/innovation/language/dot-grid/index.html
     LANGUAGE · DOT.GRID (EN/中文) · 4 LENSES (INFORMAL / FORMAL / PLATFORM / ENGINEERING)
     NOTES:
       - EN + 中文 only
       - PLATFORM/ENGINEERING mapped to gd_depth:
           depth=explore => PLATFORM
           depth=learn   => ENGINEERING
       - INFORMAL/FORMAL mapped to gd_style
       - Auto-close accordion (only one open at a time; tap again closes)
       - No modals, no overlays, no inline onclick
       - Canon state carry: lang/style/time/depth (URL + gd_* localStorage)
       - Uses ui.css + branch.css + instruments.js only
       - Does NOT style html/body background (ui.css owns field)
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>LANGUAGE · DOT.GRID</title>

<link rel="stylesheet" href="/assets/ui.css"/>
<link rel="stylesheet" href="/assets/branch.css"/>
<script defer src="/assets/instruments.js"></script>

<style>
a{color:inherit;text-decoration:none}
body::before,body::after{pointer-events:none!important}

/* ===== TOKENS ===== */
:root{
  --dockH:92px;

  --opalA:rgba(210,190,255,.16);
  --opalB:rgba(120,70,255,.12);
  --opalC:rgba(90,210,255,.08);
  --goldSoft:rgba(212,175,55,.35);

  --stroke:rgba(255,255,255,.12);
  --stroke2:rgba(255,255,255,.10);
}

/* ===== PAGE ===== */
.page{
  width:min(1100px,94vw);
  margin:0 auto;
  padding:14px 0 calc(var(--dockH) + 18px);
  display:flex;
  flex-direction:column;
  gap:12px;
  position:relative;
  z-index:10;
}

/* ===== TOP (MOBILE SAFE) ===== */
.top{
  position:sticky;
  top:0;
  z-index:240;
  padding:10px 0 6px;
  display:flex;
  justify-content:space-between;
  gap:12px;
}
.top .left,.top .right{
  display:flex;
  gap:10px;
  flex-wrap:nowrap;
  white-space:nowrap;
  align-items:center;
}
.top .btn{white-space:nowrap}

/* ===== HEADER ===== */
.header{
  border:1px solid var(--stroke);
  border-radius:22px;
  background:
    radial-gradient(circle at 20% 22%, var(--opalA), transparent 72%),
    radial-gradient(circle at 82% 60%, var(--opalB), transparent 74%),
    radial-gradient(circle at 55% 110%, var(--opalC), transparent 62%),
    linear-gradient(160deg, rgba(0,0,0,.30), rgba(0,0,0,.14));
  backdrop-filter:blur(10px);
  box-shadow:0 24px 80px rgba(0,0,0,.55);
  padding:14px 16px;
}
.k{margin:0 0 6px;font-size:11px;letter-spacing:4px;text-transform:uppercase;opacity:.74}
.t{margin:0;font-weight:950;font-size:26px;letter-spacing:.8px}
.s{margin:10px 0 0;font-size:13.75px;opacity:.90;line-height:1.55;max-width:980px}
.fine{margin-top:10px;font-size:12.25px;opacity:.72;line-height:1.45}

/* ===== LENSES (4 pills) ===== */
.lenses{
  margin-top:12px;
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}
.lenses .btn{
  border-radius:999px;
  padding:10px 12px;
}
.lenses .btn.active{
  box-shadow:0 0 0 1px rgba(212,175,55,.35), 0 0 18px rgba(212,175,55,.18);
}

/* ===== BAND ===== */
.band{
  padding:10px 12px;
  border-radius:18px;
  border:1px solid var(--stroke2);
  background:rgba(0,0,0,.14);
  font-weight:950;
  letter-spacing:.2px;
  color:rgba(255,255,255,.88);
}

/* ===== ACCORDION (LONG BUBBLES) ===== */
.stack{display:flex;flex-direction:column;gap:12px}

.card{
  position:relative;
  border:1px solid rgba(255,255,255,.10);
  border-radius:22px;
  background:
    radial-gradient(circle at 22% 18%, rgba(255,255,255,.10), transparent 58%),
    radial-gradient(circle at 78% 30%, rgba(210,190,255,.10), transparent 62%),
    linear-gradient(145deg, rgba(17,22,28,.86), rgba(11,15,20,.92));
  box-shadow:0 16px 52px rgba(0,0,0,.60);
  overflow:hidden;
}

.head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
  padding:14px 16px;
  cursor:pointer;
  -webkit-tap-highlight-color:transparent;
  touch-action:manipulation;
}
.hL{display:flex;gap:12px;align-items:flex-start;min-width:0}

/* little colored DIAMOND marker */
.dmark{
  width:10px;height:10px;
  border-radius:3px;
  transform:rotate(45deg);
  background:var(--c, rgba(212,175,55,.45));
  box-shadow:0 0 0 1px rgba(255,255,255,.14), 0 0 14px rgba(0,0,0,.35);
  flex:0 0 auto;
  margin-top:3px;
}

.name{
  font-weight:950;
  letter-spacing:.25px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
.sub{
  margin-top:6px;
  font-size:12.75px;
  opacity:.82;
  line-height:1.35;
  max-width:92ch;
}
.chev{font-size:16px;opacity:.75;flex:0 0 auto;margin-top:2px}

.body{
  display:none;
  padding:14px 16px 16px;
  border-top:1px solid rgba(255,255,255,.08);
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,.06), transparent 55%),
    linear-gradient(145deg, rgba(12,22,38,.86), rgba(7,11,18,.92));
}
.card.open .body{display:block}

.p{
  margin:0;
  color:rgba(255,255,255,.88);
  line-height:1.65;
  font-size:13.5px;
}
.p + .p{margin-top:10px}

.actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:flex-end;
  margin-top:12px;
}
.actions .btn{padding:10px 12px;border-radius:999px}

/* ===== DOCK ===== */
.dock{
  position:fixed;
  left:50%;
  bottom:max(10px, env(safe-area-inset-bottom));
  transform:translateX(-50%);
  z-index:220;
  width:min(980px,94vw);
  padding:10px 12px;
  border-radius:22px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.22);
  backdrop-filter:blur(10px);
  box-shadow:0 18px 60px rgba(0,0,0,.55);
  display:grid;
  grid-template-columns:repeat(4, minmax(0,1fr));
  gap:10px;
}
.dock .btn{width:100%;padding:10px 10px;border-radius:999px;white-space:nowrap}
@media (max-width:520px){
  :root{--dockH:98px}
  .dock{grid-template-columns:repeat(3, minmax(0,1fr))}
}
</style>
</head>

<body>

<div class="page">

  <div class="top" aria-label="Top controls">
    <div class="left">
      <a class="btn" id="btnBack" href="/explore/innovation/language/">BACK</a>
      <a class="btn" id="btnExplore" href="/explore/">EXPLORE</a>
    </div>
    <div class="right" aria-label="Language">
      <button class="btn" id="btnEN" type="button">EN</button>
      <button class="btn" id="btnZH" type="button">中文</button>
    </div>
  </div>

  <div class="header" aria-label="Header">
    <p class="k" id="hk">LANGUAGE</p>
    <h1 class="t" id="ht">DOT.GRID</h1>
    <p class="s" id="hs"></p>
    <div class="fine" id="fine"></div>

    <div class="lenses" aria-label="Lenses">
      <button class="btn" id="btnInformal" type="button">INFORMAL</button>
      <button class="btn" id="btnFormal" type="button">FORMAL</button>
      <button class="btn" id="btnPlatform" type="button">PLATFORM</button>
      <button class="btn" id="btnEngineering" type="button">ENGINEERING</button>
    </div>
  </div>

  <div class="band" id="band">DOT.GRID IN LANGUAGE</div>
  <div class="stack" id="stack"></div>

</div>

<nav class="dock" aria-label="Bottom navigation">
  <a class="btn" id="dockHome" href="/home/">HOME</a>
  <a class="btn" id="dockProducts" href="/products/">PRODUCTS</a>
  <a class="btn" id="dockLaws" href="/laws/">LAWS</a>
  <a class="btn" id="dockGauges" href="/gauges/">GAUGES</a>
</nav>

<script>
(function(){
  // ===== canonical state =====
  var qs=new URLSearchParams(location.search);
  var lang  = qs.get("lang")  || localStorage.getItem("gd_lang")  || "en";
  var style = qs.get("style") || localStorage.getItem("gd_style") || "informal";
  var time  = qs.get("time")  || localStorage.getItem("gd_time")  || "now";
  var depth = qs.get("depth") || localStorage.getItem("gd_depth") || "explore";

  // EN + 中文 only here
  if(lang!=="en" && lang!=="zh") lang="en";
  if(style!=="formal" && style!=="informal") style="informal";
  if(time==="trajectory") time="post";
  if(time!=="origin" && time!=="now" && time!=="post") time="now";

  // PLATFORM/ENGINEERING mapped to gd_depth: explore=platform, learn=engineering
  if(depth!=="explore" && depth!=="learn") depth="explore";

  try{
    localStorage.setItem("gd_lang",lang);
    localStorage.setItem("gd_style",style);
    localStorage.setItem("gd_time",time);
    localStorage.setItem("gd_depth",depth);
  }catch(e){}

  document.documentElement.lang = (lang==="zh") ? "zh" : "en";

  function q(over){
    var L=(over&&over.lang)?over.lang:lang;
    var S=(over&&over.style)?over.style:style;
    var T=(over&&over.time)?over.time:time;
    var D=(over&&over.depth)?over.depth:depth;
    return "?lang="+encodeURIComponent(L)+"&style="+encodeURIComponent(S)+"&time="+encodeURIComponent(T)+"&depth="+encodeURIComponent(D);
  }

  function wire(id, path){
    var el=document.getElementById(id);
    if(el) el.href = path + q();
  }

  // nav
  wire("btnBack","/explore/innovation/language/");
  wire("btnExplore","/explore/");
  wire("dockHome","/home/");
  wire("dockProducts","/products/");
  wire("dockLaws","/laws/");
  wire("dockGauges","/gauges/");

  // language toggle (reload SAME pathname)
  var btnEN=document.getElementById("btnEN");
  var btnZH=document.getElementById("btnZH");

  function paintLang(){
    btnEN.classList.toggle("active", lang==="en");
    btnZH.classList.toggle("active", lang==="zh");
  }
  paintLang();

  function setLang(next){
    if(next!=="en" && next!=="zh") next="en";
    lang=next;
    try{ localStorage.setItem("gd_lang",lang); }catch(e){}
    window.location.href = window.location.pathname + q({lang:lang});
  }
  btnEN.addEventListener("click", function(){ setLang("en"); });
  btnZH.addEventListener("click", function(){ setLang("zh"); });

  // ===== lenses =====
  var btnInformal=document.getElementById("btnInformal");
  var btnFormal=document.getElementById("btnFormal");
  var btnPlatform=document.getElementById("btnPlatform");
  var btnEngineering=document.getElementById("btnEngineering");

  function track(){ return (depth==="learn") ? "engineering" : "platform"; } // learn => engineering
  function setTrack(next){
    depth = (next==="engineering") ? "learn" : "explore";
    try{ localStorage.setItem("gd_depth", depth); }catch(e){}
    paintLenses();
    render();
  }
  function setStyle(next){
    style = (next==="formal") ? "formal" : "informal";
    try{ localStorage.setItem("gd_style", style); }catch(e){}
    paintLenses();
    render();
  }

  function paintLenses(){
    btnInformal.classList.toggle("active", style==="informal");
    btnFormal.classList.toggle("active", style==="formal");
    btnPlatform.classList.toggle("active", track()==="platform");
    btnEngineering.classList.toggle("active", track()==="engineering");

    if(lang==="zh"){
      btnInformal.textContent="通俗";
      btnFormal.textContent="正式";
      btnPlatform.textContent="平台";
      btnEngineering.textContent="工程";
    }else{
      btnInformal.textContent="INFORMAL";
      btnFormal.textContent="FORMAL";
      btnPlatform.textContent="PLATFORM";
      btnEngineering.textContent="ENGINEERING";
    }
  }

  btnInformal.addEventListener("click", function(){ setStyle("informal"); });
  btnFormal.addEventListener("click", function(){ setStyle("formal"); });
  btnPlatform.addEventListener("click", function(){ setTrack("platform"); });
  btnEngineering.addEventListener("click", function(){ setTrack("engineering"); });

  paintLenses();

  // ===== copy =====
  function pick(en, zh){ return (lang==="zh") ? zh : en; }

  var HEAD = {
    en:{
      hk:"LANGUAGE",
      ht:"DOT.GRID",
      hs:"Dot.Grid is the language lane that turns ‘a pile of concepts’ into a navigable map. It’s how we stop meaning from drifting when the system grows.",
      fine:"Informal = TED-talk clarity. Formal = precise definitions. Platform = what users see. Engineering = what must be true underneath."
    },
    zh:{
      hk:"语言",
      ht:"DOT.GRID",
      hs:"Dot.Grid 是语言通道：把“一堆概念”变成可遍历地图。系统越大越容易漂移，而它的任务就是把含义钉住。",
      fine:"通俗=TED式清晰；正式=精确定义；平台=用户看到的；工程=底层必须为真的。"
    }
  };

  // Cards: each has 4 variants: (style informal/formal) × (track platform/engineering)
  // Each variant has 2 paragraphs (dense but readable).
  var CARDS = [
    {
      c:"#D4AF37",
      t:{en:"What Dot.Grid means (in language)", zh:"Dot.Grid 在语言里意味着什么"},
      s:{en:"A map for meaning: you can move, you can return, you don’t get lost.", zh:"含义地图：能前进、能返回、不迷路。"},
      body:{
        informal:{
          platform:{
            en:[
              "Most language systems fail the same way most products fail: everything starts simple… then it grows, and nobody can explain what connects to what anymore.",
              "Dot.Grid fixes that. It gives your learning system a *map*. You can point to a node, see what it depends on, and know what comes next. That’s how you keep progress calm instead of chaotic."
            ],
            zh:[
              "很多语言系统的失败方式，和很多产品的失败方式一样：一开始很简单——然后越做越大，最后谁也说不清“这个和那个到底怎么连着”。",
              "Dot.Grid 的作用就是给学习系统一张*地图*：你能指向一个节点，看到它依赖什么，知道下一步去哪。进步因此变得平静，不再靠运气。"
            ]
          },
          engineering:{
            en:[
              "Language drift happens when definitions move silently. The same word starts meaning different things on different pages, and the learner feels it as confusion.",
              "Dot.Grid prevents that by forcing stable node names, stable adjacency, and stable routes. If the map changes, it’s logged and visible—so the system can’t gaslight the learner."
            ],
            zh:[
              "语言漂移最常见的形式是：定义悄悄移动。同一个词在不同页面变成不同意思，学习者体验到的就是困惑。",
              "Dot.Grid 通过强制稳定节点名、稳定邻接关系、稳定路线来阻止漂移。地图一变就可见、可记录，系统就无法“悄悄换义”。"
            ]
          }
        },
        formal:{
          platform:{
            en:[
              "Dot.Grid is a traversal contract for terminology: a node is a declared term with a declared scope, and edges describe allowed transitions and dependency prerequisites.",
              "The platform posture is legibility: the learner should always know where they are, what a term means here, and what the next admissible step is—without re-reading the entire system."
            ],
            zh:[
              "Dot.Grid 是术语遍历契约：节点=在声明范围内的声明术语；边=允许的转移与依赖前置条件。",
              "平台姿态强调可读性：学习者无需重读全系统，也能知道自己在哪、此处术语含义为何、以及下一步的可采信动作是什么。"
            ]
          },
          engineering:{
            en:[
              "Dot.Grid constrains semantics by fixing identifiers and adjacency under declared measurement/authoring rules. Meaning drift is treated as a structural mutation, not a stylistic change.",
              "Any mutation that affects interpretation requires explicit epoching (or explicit versioning) to preserve comparability of learner progress and content audits."
            ],
            zh:[
              "Dot.Grid 通过固定标识符与邻接关系（在声明的编写/测量规则下）来约束语义。含义漂移被视为结构变异，而非文风变化。",
              "任何影响解释的变更必须显式进入新纪元（或版本化），以保持学习进度与内容审计的可比性。"
            ]
          }
        }
      },
      jumps:[
        {en:"OPEN: LANGUAGE HUB", zh:"打开：语言枢纽", href:"/explore/innovation/language/"},
        {en:"OPEN: DOT.GRID (PRODUCT)", zh:"打开：Dot.Grid（产品）", href:"/products/dot-grid/"}
      ]
    },

    {
      c:"#0EA5E9",
      t:{en:"Traversal learning vs linear learning", zh:"遍历学习 vs 线性学习"},
      s:{en:"Linear is a line. Traversal is a map. Maps scale.", zh:"线性是直线；遍历是地图；地图可规模化。"},
      body:{
        informal:{
          platform:{
            en:[
              "Linear learning is ‘page 1, page 2, page 3.’ It works until real life shows up and you need to jump—then the learner loses the thread.",
              "Traversal learning is different: it lets you jump on purpose. You can learn what you need today, come back tomorrow, and still know where you are. That’s how language becomes usable fast."
            ],
            zh:[
              "线性学习是“第一页、第二页、第三页”。它在理想情况下可以，但一旦真实生活出现、你需要跳转，学习者就断线。",
              "遍历学习不是这样：它允许你*有目的地跳*。今天学你用得上的，明天回来仍然知道自己在哪。语言因此更快变成可用能力。"
            ]
          },
          engineering:{
            en:[
              "Traversal only works if the map is stable. If routes change or terms drift, jumping becomes chaos instead of freedom.",
              "Dot.Grid is the rule that keeps traversal honest: you can jump, but the system must preserve state and meaning, or it’s a failure."
            ],
            zh:[
              "遍历只有在地图稳定时才成立。路线一变、术语一漂移，跳转就会从自由变成混乱。",
              "Dot.Grid 就是让遍历诚实的规则：你可以跳，但系统必须保留状态与含义，否则就是失败。"
            ]
          }
        },
        formal:{
          platform:{
            en:[
              "Traversal learning is graph-based: nodes represent bounded competencies, edges represent prerequisites and allowed transitions. The learner follows routes appropriate to their context.",
              "The platform contract is state-preserving navigation: the learner’s lens and position must survive jumps so that traversal does not induce cognitive debt."
            ],
            zh:[
              "遍历学习是图结构：节点=有界能力，边=前置与允许转移。学习者按情境选择路线。",
              "平台契约是状态保留导航：学习者的透镜与位置必须在跳转中保持，否则遍历会制造认知债。"
            ]
          },
          engineering:{
            en:[
              "Graph traversal requires invariant identifiers, versioned definitions, and deterministic routing rules. Otherwise, paths are not reproducible and progress cannot be audited.",
              "Dot.Grid supplies those invariants at the language layer: stable naming, stable adjacency, and explicit evolution rules."
            ],
            zh:[
              "图遍历需要不变标识符、版本化定义与确定性路由规则，否则路径不可复现、进度不可审计。",
              "Dot.Grid 在语言层提供这些不变量：稳定命名、稳定邻接与显式演化规则。"
            ]
          }
        }
      },
      jumps:[
        {en:"OPEN: EXPLORE", zh:"打开：探索", href:"/explore/"},
        {en:"OPEN: EDUCATION", zh:"打开：教育", href:"/products/education/"}
      ]
    },

    {
      c:"#F59E0B",
      t:{en:"The sweep idea (why ‘clusters’ matter)", zh:"扫掠思想（为什么集群重要）"},
      s:{en:"When things move together, you learn faster—or fail faster.", zh:"一起动=一起学更快，或一起坏更快。"},
      body:{
        informal:{
          platform:{
            en:[
              "A ‘cluster’ is just a group that moves together. In language learning, clusters are sneaky: one missing connector can break five sentences.",
              "Dot.Grid teaches you to see those clusters. That’s why it feels like acceleration: you stop fixing random mistakes and start fixing the shared root."
            ],
            zh:[
              "“集群”就是一组会一起动的东西。在语言学习里，集群很隐蔽：一个连接词不会，五个句子都崩。",
              "Dot.Grid 让你看见这些集群。所以它像加速器：你不再随机修错，而是修共享根因。"
            ]
          },
          engineering:{
            en:[
              "If a cluster is real, it should show up repeatedly under similar practice windows. If it only appears once, it’s probably noise.",
              "So Dot.Grid treats clusters as signals to investigate, not as conclusions. It points; other layers decide."
            ],
            zh:[
              "如果集群是真的，它应该在类似练习窗口里反复出现；只出现一次，多半是噪声。",
              "所以 Dot.Grid 把集群当作“值得调查的信号”，不是结论：它指路，其他层裁决。"
            ]
          }
        },
        formal:{
          platform:{
            en:[
              "Sweeps are windowed passes that reveal correlated performance movements across nodes. They help identify shared dependencies and shared failure modes.",
              "Platform posture: show the learner which nodes are likely coupled so effort can be focused without inflating claims."
            ],
            zh:[
              "扫掠是窗口化遍历，用于发现节点间的相关表现变化，识别共享依赖与共享失败模式。",
              "平台姿态：把可能耦合的节点展示给学习者，让努力更聚焦，但不膨胀主张。"
            ]
          },
          engineering:{
            en:[
              "Sweep outputs are descriptive: correlation indicators, drift deltas, and adjacency changes. They do not assert causality and do not assert admissibility.",
              "Interpretation bounds are delegated: Gauges displays measurements; Laws constrains what may be concluded."
            ],
            zh:[
              "扫掠输出是描述性的：相关指示、漂移差分、邻接变化。不主张因果，不主张可采信。",
              "解释边界交由下游：量规展示测量，法则约束结论。"
            ]
          }
        }
      },
      jumps:[
        {en:"OPEN: GAUGES", zh:"打开：量规", href:"/gauges/"},
        {en:"OPEN: LAWS", zh:"打开：法则", href:"/laws/"}
      ]
    },

    {
      c:"#93C5FD",
      t:{en:"How it connects to SSG", zh:"它如何连接到 SSG"},
      s:{en:"SSG is geometry. Dot.Grid is the language map that rides on top.", zh:"SSG 是几何；Dot.Grid 是其上的语言地图。"},
      body:{
        informal:{
          platform:{
            en:[
              "SSG tells you how the machine behaves. Dot.Grid tells you how the *words* stay stable while the machine grows.",
              "That combination is the whole point: you get power without drift. Big systems, still explainable."
            ],
            zh:[
              "SSG 负责“机器怎么跑”；Dot.Grid 负责“词怎么保持稳定”。",
              "两者合起来才有意义：系统变大但不漂移；很强但仍可解释。"
            ]
          },
          engineering:{
            en:[
              "When SSG changes behavior, Dot.Grid forces the language layer to stamp the change. No silent ‘meaning swaps.’",
              "So you can scale documents, training, and product surfaces without rewriting history."
            ],
            zh:[
              "当 SSG 改变行为，Dot.Grid 强制语言层盖章：不允许静默换义。",
              "因此你能规模化文档、训练、产品界面，而不改写历史。"
            ]
          }
        },
        formal:{
          platform:{
            en:[
              "SSG defines execution primitives and constraint rules. Dot.Grid defines a traversal representation of terms and concepts used to describe those primitives.",
              "Platform goal: user legibility under growth—stable labels, stable routes, and predictable meaning."
            ],
            zh:[
              "SSG 定义执行原语与约束规则；Dot.Grid 定义用于描述这些原语的术语/概念遍历表示。",
              "平台目标：增长下仍可读——稳定标签、稳定路线、可预测含义。"
            ]
          },
          engineering:{
            en:[
              "Dot.Grid provides semantic versioning posture aligned with SSG invariants: stable identifiers, explicit scope locks, and auditable evolution.",
              "This allows observer-invariant interpretation across time: the same label refers to the same bounded meaning under the same epoch."
            ],
            zh:[
              "Dot.Grid 提供与 SSG 不变量一致的语义版本姿态：稳定标识符、显式范围锁、可审计演化。",
              "从而支持跨时间的观察者不变解释：同标签在同纪元下指向同一有界含义。"
            ]
          }
        }
      },
      jumps:[
        {en:"OPEN: SSG", zh:"打开：SSG", href:"/products/ssg/"},
        {en:"OPEN: SOFTWARE HUB", zh:"打开：软件枢纽", href:"/products/software/"}
      ]
    },

    {
      c:"#A3A3A3",
      t:{en:"Boundaries (what this page refuses to do)", zh:"边界（本页拒绝做什么）"},
      s:{en:"No hype. No claims beyond the map. Just clarity.", zh:"不吹牛、不越界：只给清晰。"},
      body:{
        informal:{
          platform:{
            en:[
              "This page won’t promise you ‘fluency.’ It won’t pretend a map is the same as a result.",
              "What it will do is keep you oriented so your effort turns into outcomes instead of confusion."
            ],
            zh:[
              "本页不会承诺“流利”，也不会把“地图”当成“结果”。",
              "它只做一件事：让你一直有方向感，让努力变成结果，而不是困惑。"
            ]
          },
          engineering:{
            en:[
              "If a definition changes, we mark it. If a route changes, we mark it. If a term drifts, that’s a failure to fix—not something to hide.",
              "That’s how we keep trust: meaning doesn’t move under your feet."
            ],
            zh:[
              "定义变了要标记；路线变了要标记；术语漂移就是失败——要修，不要藏。",
              "信任来自这一点：含义不会在你脚下悄悄移动。"
            ]
          }
        },
        formal:{
          platform:{
            en:[
              "Dot.Grid (language lane) is descriptive and navigational. It does not output admissibility classifications and does not output causal conclusions.",
              "Any measurement claims route to Gauges; any interpretation bounds route to Laws."
            ],
            zh:[
              "Dot.Grid（语言通道）是描述性与导航性的：不输出可采信分类，不输出因果结论。",
              "任何测量主张去量规；任何解释边界去法则。"
            ]
          },
          engineering:{
            en:[
              "Non-negotiables: stable identifiers, stable scope, explicit epoching for changes, and deterministic state propagation. Missing propagation is a structural defect.",
              "If the same evidence yields different interpretations, the measurement rules must be corrected—not patched with narrative."
            ],
            zh:[
              "不可谈判：稳定标识符、稳定范围、变更显式纪元化、确定性状态传播。缺失传播即结构缺陷。",
              "若同证据产生不同解释，应修正测量规则，而非用叙事打补丁。"
            ]
          }
        }
      },
      jumps:[
        {en:"OPEN: LAWS", zh:"打开：法则", href:"/laws/"},
        {en:"OPEN: DOOR", zh:"打开：DOOR", href:"/door/"}
      ]
    }
  ];

  // header render
  var H=(lang==="zh")?HEAD.zh:HEAD.en;
  document.getElementById("hk").textContent=H.hk;
  document.getElementById("ht").textContent=H.ht;
  document.getElementById("hs").textContent=H.hs;
  document.getElementById("fine").textContent=H.fine;

  // band
  document.getElementById("band").textContent = (lang==="zh") ? "DOT.GRID（语言通道）" : "DOT.GRID (LANGUAGE LANE)";

  // ===== accordion auto-close (only one open) =====
  var stack=document.getElementById("stack");

  function closeAll(){
    var cards=stack.querySelectorAll(".card");
    cards.forEach(function(c){
      c.classList.remove("open");
      var cv=c.querySelector(".chev");
      if(cv) cv.textContent="▸";
    });
  }

  function makeCard(item, idx){
    var card=document.createElement("div");
    card.className="card";

    var head=document.createElement("div");
    head.className="head";
    head.setAttribute("role","button");
    head.setAttribute("tabindex","0");

    var hL=document.createElement("div");
    hL.className="hL";

    var mark=document.createElement("div");
    mark.className="dmark";
    mark.style.setProperty("--c", item.c);
    mark.style.background=item.c;

    var left=document.createElement("div");
    left.style.minWidth="0";

    var name=document.createElement("div");
    name.className="name";
    name.textContent = pick(item.t.en, item.t.zh);

    var sub=document.createElement("div");
    sub.className="sub";
    sub.textContent = pick(item.s.en, item.s.zh);

    left.appendChild(name);
    left.appendChild(sub);

    hL.appendChild(mark);
    hL.appendChild(left);

    var chev=document.createElement("div");
    chev.className="chev";
    chev.textContent="▸";

    head.appendChild(hL);
    head.appendChild(chev);

    var body=document.createElement("div");
    body.className="body";

    var modeStyle = style; // informal/formal
    var modeTrack = track(); // platform/engineering

    var paras = item.body[modeStyle][modeTrack][lang] || item.body[modeStyle][modeTrack].en;

    for(var i=0;i<paras.length;i++){
      var p=document.createElement("p");
      p.className="p";
      p.textContent=paras[i];
      body.appendChild(p);
    }

    var actions=document.createElement("div");
    actions.className="actions";
    for(var k=0;k<item.jumps.length;k++){
      var a=document.createElement("a");
      a.className="btn";
      a.textContent = (lang==="zh") ? item.jumps[k].zh : item.jumps[k].en;
      a.href = item.jumps[k].href + q();
      actions.appendChild(a);
    }
    body.appendChild(actions);

    function toggle(){
      var willOpen = !card.classList.contains("open");
      closeAll();
      if(willOpen){
        card.classList.add("open");
        chev.textContent="▾";
      }else{
        chev.textContent="▸";
      }
    }

    head.addEventListener("click", toggle);
    head.addEventListener("keydown", function(e){
      if(e.key==="Enter"||e.key===" "){ e.preventDefault(); toggle(); }
    });

    card.appendChild(head);
    card.appendChild(body);

    // open first card by default
    if(idx===0){
      card.classList.add("open");
      chev.textContent="▾";
    }

    return card;
  }

  function render(){
    paintLang();
    paintLenses();

    stack.innerHTML="";
    for(var i=0;i<CARDS.length;i++){
      stack.appendChild(makeCard(CARDS[i], i));
    }

    // top + dock labels
    if(lang==="zh"){
      document.getElementById("btnBack").textContent="返回";
      document.getElementById("btnExplore").textContent="探索";
      document.getElementById("dockHome").textContent="主页";
      document.getElementById("dockProducts").textContent="产品";
      document.getElementById("dockLaws").textContent="法则";
      document.getElementById("dockGauges").textContent="量规";
    }else{
      document.getElementById("btnBack").textContent="BACK";
      document.getElementById("btnExplore").textContent="EXPLORE";
      document.getElementById("dockHome").textContent="HOME";
      document.getElementById("dockProducts").textContent="PRODUCTS";
      document.getElementById("dockLaws").textContent="LAWS";
      document.getElementById("dockGauges").textContent="GAUGES";
    }
  }

  // re-render on lens changes
  function rerender(){ render(); }

  // hook lens changes to rerender
  var _setStyle=setStyle;
  setStyle=function(next){ _setStyle(next); rerender(); };
  var _setTrack=setTrack;
  setTrack=function(next){ _setTrack(next); rerender(); };

  // initial render
  render();

})();
</script>

</body>
</html>
