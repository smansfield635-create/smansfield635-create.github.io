<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Results · Alignment Check · Geodiametrics</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/assets/ui.css" />
  <style>
    .card{margin-top:14px;padding:16px;border-radius:18px;background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.03));border:1px solid rgba(255,255,255,.18)}
    .muted{color:#b9c6d3}
    .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
    .btn{padding:10px 16px;border-radius:18px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:#e8eef5;cursor:pointer}
    .btn.primary{border-color:#6faad6;color:#6faad6}
    .scoregrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .score{padding:12px;border-radius:16px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.14)}
    .score b{display:block;font-size:1.05rem;margin-bottom:4px}
    .pill{display:inline-block;margin-top:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08)}
  </style>
</head>
<body>
  <main class="page" data-mode="leaf">
    <div class="title">Results</div>
    <div class="subtitle">Alignment check — not a quiz. Check yourself before you wreck yourself.</div>

    <section class="panel">
      <div class="card">
        <div class="muted" id="meta"></div>

        <div class="scoregrid" id="scores"></div>

        <div class="row">
          <button class="btn" id="back">Back</button>
          <button class="btn" id="restart">Restart</button>
          <button class="btn primary" id="enter">Enter site</button>
        </div>
      </div>

      <div class="footer">Canonical · Stable · © Geodiametrics</div>
    </section>
  </main>

  <script>
    (function(){
      // Mirror the scoring tags from leaf DB:
      // (Keep this minimal: scoring is count-based on A/E/H/D tags)
      const TYPE = {
        architect:"Architect",
        executor:"Executor",
        harmonizer:"Harmonizer",
        disruptor:"Disruptor"
      };

      // Load user state
      const self = localStorage.getItem("alignment_self_type") || "";
      const picks16 = JSON.parse(localStorage.getItem("alignment_picks16")||"{}");
      const refine = JSON.parse(localStorage.getItem("alignment_refine")||"[]");
      const order = JSON.parse(localStorage.getItem("alignment_order")||"[]");
      const firstSection = localStorage.getItem("alignment_first_section") || "";

      // If incomplete, bounce
      if(Object.keys(picks16).length < 16){
        location.href="/landing/leaf/";
        return;
      }

      // Minimal scoring model:
      // Required picks weight = 1.0
      // Refine picks weight = 0.5
      // We don’t re-load the full sayings DB here; we score via stored tags in order-log if present.
      // If tags are absent, we still compute structure-only (counts) using selection indices as equal weight.

      // Since we did not store tags per selection, we approximate score by exploration structure:
      // - self type gets +1 bias if user chose it (self-lens)
      // - earliest exploration lens (first section) gives +0.5 to Harmonizer if Ancient-first,
      //   +0.5 to Disruptor if Contemporary-first, +0.5 Architect if Greece/China first, +0.5 Executor if India/Egypt first.
      // This is intentionally conservative until we store saying-tags later.

      const score = {architect:0, executor:0, harmonizer:0, disruptor:0};

      // Self-perception lens
      if(score[self] != null) score[self] += 1.0;

      // First section structural lens
      if(firstSection){
        const [era,country] = firstSection.split("|");
        if(era==="Ancient") score.harmonizer += 0.5;
        if(era==="Contemporary") score.disruptor += 0.5;
        if(country==="Greece" || country==="China") score.architect += 0.5;
        if(country==="India" || country==="Egypt") score.executor += 0.5;
      }

      // Completion / commitment lens (all 16 done)
      score.architect += 0.5;
      score.executor += 0.5;
      score.harmonizer += 0.5;
      score.disruptor += 0.5;

      // Refine lens (optional)
      if(refine.length){
        // Refining implies diligence (Architect) and conviction (Executor)
        score.architect += 0.25 * refine.length;
        score.executor += 0.25 * refine.length;
      }

      // Rank
      const ranked = Object.entries(score).sort((a,b)=>b[1]-a[1]);
      const primary = ranked[0][0];
      const secondary = ranked[1][0];
      const least = ranked[ranked.length-1][0];

      document.getElementById("meta").innerHTML =
        `Self-lens: <b>${TYPE[self] || "Unspecified"}</b> · Primary: <b>${TYPE[primary]}</b> · Secondary: <b>${TYPE[secondary]}</b> · Least: <b>${TYPE[least]}</b>
         <div class="pill">Required: 16 complete</div> <div class="pill">Refine: ${refine.length}/4</div>`;

      const scoresEl = document.getElementById("scores");
      ranked.forEach(([k,v])=>{
        const d = document.createElement("div");
        d.className="score";
        d.innerHTML = `<b>${TYPE[k]}</b><div class="muted">Score: ${v.toFixed(2)}</div>`;
        scoresEl.appendChild(d);
      });

      document.getElementById("back").addEventListener("click", ()=>location.href="/landing/leaf/");
      document.getElementById("enter").addEventListener("click", ()=>location.href="/home/");
      document.getElementById("restart").addEventListener("click", ()=>{
        localStorage.removeItem("alignment_started");
        localStorage.removeItem("alignment_self_type");
        localStorage.removeItem("alignment_picks16");
        localStorage.removeItem("alignment_refine");
        localStorage.removeItem("alignment_first_section");
        localStorage.removeItem("alignment_order");
        location.href="/landing/index.html";
      });
    })();
  </script>
</body>
</html>
