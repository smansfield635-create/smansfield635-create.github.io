/* =========================================================
   GEODIAMETRICS Â· SEARCH ENGINE QUAD-CORES
   Four lawful instantiations of the same cycle
   No overlap. No manual control.
========================================================= */

const ENGINE_PREFIX = "ENGINE::SEARCH::";
const nowISO = () => new Date().toISOString();

/* ---- Quad-Core Factory ---- */
function createQuadCore(name, domain){
  return {
    name,
    domain,
    state: {
      selection: null,
      resolution: null,
      commitment: null,
      continuation: {
        cycle: "IDLE",
        last_set: null
      }
    },
    updated_at: null
  };
}

/* ---- Engine Registry ---- */
const SearchEngines = {
  INGEST: createQuadCore(
    "Ingest Engine",
    "Source collection, normalization, acceptance"
  ),

  INDEX: createQuadCore(
    "Index Engine",
    "Tokenization, structure, validation"
  ),

  QUERY: createQuadCore(
    "Query & Rank Engine",
    "Interpretation, retrieval, scoring"
  ),

  FEEDBACK: createQuadCore(
    "Feedback & Update Engine",
    "Observation, correction, stabilization"
  )
};

/* ---- Persistence ---- */
function saveEngine(key, engine){
  engine.updated_at = nowISO();
  localStorage.setItem(
    ENGINE_PREFIX + key,
    JSON.stringify(engine)
  );
}

function loadEngine(key){
  const raw = localStorage.getItem(ENGINE_PREFIX + key);
  return raw ? JSON.parse(raw) : null;
}

/* ---- Initialization ---- */
function registerSearchEngines(){
  Object.keys(SearchEngines).forEach(k => {
    const existing = loadEngine(k);
    if(existing){
      SearchEngines[k] = existing;
    } else {
      saveEngine(k, SearchEngines[k]);
    }
  });
}

/* ---- Lawful Transitions (no UI hooks here) ---- */
function advanceSelection(key, value){
  const e = loadEngine(key);
  if(!e) return;
  e.state.selection = value;
  e.state.continuation = { cycle: "SELECTED", last_set: nowISO() };
  saveEngine(key, e);
}

function resolve(key, value){
  const e = loadEngine(key);
  if(!e || !e.state.selection) return;
  e.state.resolution = value;
  e.state.continuation = { cycle: "RESOLVED", last_set: nowISO() };
  saveEngine(key, e);
}

function commit(key, value){
  const e = loadEngine(key);
  if(!e || !e.state.resolution) return;
  e.state.commitment = value;
  e.state.continuation = { cycle: "COMMITTED", last_set: nowISO() };
  saveEngine(key, e);
}

function continueCycle(key){
  const e = loadEngine(key);
  if(!e || !e.state.commitment) return;
  e.state.continuation = { cycle: "CONTINUING", last_set: nowISO() };
  saveEngine(key, e);
}

/* ---- Boot ---- */
registerSearchEngines();
