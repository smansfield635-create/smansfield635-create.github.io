<!-- TNT — /home/index.html
     HUB A · DIAMOND FORK (BRANCHED) + RUSSIAN DOLL SCROLL
     START VIEW: N / E / S / W ONLY
     BRANCH VIEW:
       N -> NE, NW -> (NE->ENE, NW->WNW)
       E -> ENE, ESE
       S -> SSE, SSW -> (SSE->ESE, SSW->WSW)
       W -> WNW, WSW -> (WNW->NNW, WSW->SSW)
     CONTENT:
       Each node can carry ONE summary paragraph per lens (Informal/Formal), hidden until node opened.
       View toggle controls visibility: Informal / Formal / Both
       Language toggle: EN / 中文
     CANON KEYS ONLY: gd_lang / gd_style / gd_time
-->

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HUB A · Index</title>

<link rel="stylesheet" href="/assets/ui.css"/>
<link rel="stylesheet" href="/assets/branch.css"/>

<style>
/* DO NOT TOUCH FIELD — ui.css owns html/body background */
body{margin:0;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
a{color:inherit;text-decoration:none}
:root{--dockH:92px}
.wrap{
  width:min(980px,94vw);
  margin:0 auto;
  padding:14px 0 calc(var(--dockH) + 22px);
  display:flex;
  flex-direction:column;
  gap:12px;
}

/* ===== Header ===== */
.brand{
  border:1px solid rgba(255,255,255,.10);
  border-radius:22px;
  padding:14px 16px;
  background:rgba(0,0,0,.14);
  backdrop-filter:blur(10px);
  box-shadow:0 24px 80px rgba(0,0,0,.55);
}
.brand .k{font-size:11px;letter-spacing:4px;text-transform:uppercase;opacity:.70;margin:0 0 6px}
.brand .t{font-weight:950;font-size:24px;letter-spacing:.3px;margin:0 0 6px}
.brand .s{font-size:13px;opacity:.80;line-height:1.5;margin:0;max-width:820px}

/* ===== Controls ===== */
.controls{display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap;margin-top:10px}
.seg{
  display:inline-flex;border:1px solid rgba(255,255,255,.12);
  border-radius:999px;overflow:hidden;background:rgba(0,0,0,.18);
  backdrop-filter:blur(10px);
  box-shadow:0 12px 34px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.07);
}
.seg button{
  border:0;background:transparent;color:rgba(255,255,255,.86);
  padding:9px 14px;font-weight:950;letter-spacing:.2px;cursor:pointer;
  -webkit-tap-highlight-color:transparent;
}
.seg button.on{background:rgba(255,255,255,.15);color:#fff}

/* ===== Node (bubble) ===== */
.node{
  --c:#93C5FD;
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;
  background:
    radial-gradient(circle at 30% 20%, rgba(255,255,255,.06), transparent 55%),
    linear-gradient(160deg, rgba(12,22,38,.92), rgba(7,11,18,.95));
  box-shadow:0 18px 60px rgba(0,0,0,.62);
  overflow:hidden;
}
.nHead{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:14px 16px;cursor:pointer;font-weight:950;letter-spacing:.2px;
}
.nLeft{display:flex;align-items:center;gap:10px;min-width:0}
.diamond{
  width:12px;height:12px;transform:rotate(45deg);border-radius:4px;background:var(--c);
  box-shadow:0 0 0 1px rgba(255,255,255,.12),0 0 14px rgba(0,0,0,.35);
  flex:0 0 auto;pointer-events:none;
}
.nLabel{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.nBody{
  display:none;
  padding:12px 14px 14px;
  border-top:1px solid rgba(255,255,255,.08);

  /* Russian doll scroll region for any open node */
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
.node.open .nBody{display:block}

/* children stack (branching) */
.childStack{display:flex;flex-direction:column;gap:10px;margin-top:12px}

/* content blocks */
.lensBlock{
  border:1px solid rgba(255,255,255,.10);
  border-radius:14px;
  padding:12px 14px;
  background:rgba(0,0,0,.18);
  margin-bottom:10px;
  box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
}
.lensTitle{font-weight:950;font-size:12px;margin:0 0 8px;opacity:.88}
.paragraph{margin:0;line-height:1.72;font-size:14.5px;color:rgba(255,255,255,.90)}
.indexLine{
  margin-top:10px;padding:10px 12px;border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.14);
  font-size:12.5px;color:rgba(255,255,255,.80)
}
.indexLine a{color:#93C5FD;font-weight:950;text-decoration:none}

/* view filter */
.view-formal .lensBlock[data-lens="informal"]{display:none}
.view-informal .lensBlock[data-lens="formal"]{display:none}
.view-both .lensBlock{display:block}

/* ===== Bottom dock (mobile safe grid) ===== */
.bottomDock{
  position:fixed;
  left:50%;
  bottom:max(10px, env(safe-area-inset-bottom));
  transform:translateX(-50%);
  z-index:220;
  width:min(980px,94vw);
  padding:10px 12px;
  border-radius:22px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.22);
  backdrop-filter:blur(10px);
  box-shadow:0 18px 60px rgba(0,0,0,.55);

  display:grid;
  grid-template-columns:repeat(4, minmax(0,1fr));
  gap:10px;
}
.dbtn{
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.20);
  color:#fff;
  padding:10px 10px;
  border-radius:999px;
  font-weight:900;
  letter-spacing:.2px;
  cursor:pointer;
  text-align:center;
  white-space:nowrap;
}
.dbtn:hover{background:rgba(255,255,255,.10)}
.dbtn.full{grid-column:1 / -1;}

@media (max-width:520px){
  .bottomDock{grid-template-columns:repeat(3, minmax(0,1fr))}
  .dbtn.full{grid-column:1 / -1;}
}
</style>
</head>

<body>

<div class="wrap">
  <div class="brand" id="brand">
    <div class="k" id="bk">CARDINAL AXIS</div>
    <div class="t" id="bt">HUB A · Index</div>
    <p class="s" id="bs">Diamond fork index. Start with N/E/S/W. Expand to branches only when selected.</p>

    <div class="controls">
      <div class="seg" aria-label="View">
        <button id="viewInformal" type="button">INFORMAL</button>
        <button id="viewFormal" type="button">FORMAL</button>
        <button id="viewBoth" type="button">BOTH</button>
      </div>
      <div class="seg" aria-label="Language">
        <button id="langEN" type="button">EN</button>
        <button id="langZH" type="button">中文</button>
      </div>
    </div>
  </div>

  <div id="root"></div>
</div>

<div class="bottomDock" id="dock" aria-label="Navigation">
  <button class="dbtn" id="navBack" type="button">BACK</button>
  <button class="dbtn" id="navForward" type="button">FORWARD</button>
  <button class="dbtn" id="navHub" type="button">HUB</button>
  <button class="dbtn" id="navExplore" type="button">EXPLORE</button>

  <button class="dbtn" id="navProducts" type="button">PRODUCTS</button>
  <button class="dbtn" id="navLaws" type="button">LAWS</button>
  <button class="dbtn" id="navGauges" type="button">GAUGES</button>
  <button class="dbtn" id="navTop" type="button">TOP</button>

  <button class="dbtn full" id="navJump" type="button">JUMP (OPEN PROJECT)</button>
</div>

<script>
(function(){
  /* ===== Canon keys ===== */
  const qs=new URLSearchParams(location.search);
  let gd_lang  = qs.get("gd_lang")  || localStorage.getItem("gd_lang")  || "en";
  let gd_style = qs.get("gd_style") || localStorage.getItem("gd_style") || "informal";
  let gd_time  = qs.get("gd_time")  || localStorage.getItem("gd_time")  || "now";

  if(gd_lang!=="en" && gd_lang!=="zh") gd_lang="en";
  if(gd_style!=="formal" && gd_style!=="informal") gd_style="informal";
  if(gd_time==="trajectory") gd_time="post";
  if(gd_time!=="origin" && gd_time!=="now" && gd_time!=="post") gd_time="now";

  try{
    localStorage.setItem("gd_lang",gd_lang);
    localStorage.setItem("gd_style",gd_style);
    localStorage.setItem("gd_time",gd_time);
  }catch(e){}
  document.documentElement.lang = (gd_lang==="zh") ? "zh" : "en";

  function makeQS(){
    const p=new URLSearchParams();
    p.set("gd_lang",gd_lang);
    p.set("gd_style",gd_style);
    p.set("gd_time",gd_time);
    return "?"+p.toString();
  }
  function nav(path){ location.href = path + makeQS(); }
  function TL(en,zh){ return (gd_lang==="zh") ? zh : en; }

  const root=document.getElementById("root");
  const dock=document.getElementById("dock");
  const brand=document.getElementById("brand");

  /* ===== Controls ===== */
  const viewInformal=document.getElementById("viewInformal");
  const viewFormal=document.getElementById("viewFormal");
  const viewBoth=document.getElementById("viewBoth");
  const langEN=document.getElementById("langEN");
  const langZH=document.getElementById("langZH");

  function applyView(v){
    root.classList.remove("view-formal","view-informal","view-both");
    root.classList.add("view-"+v);
    viewInformal.classList.toggle("on", v==="informal");
    viewFormal.classList.toggle("on", v==="formal");
    viewBoth.classList.toggle("on", v==="both");
  }
  applyView(gd_style);

  function setHeaderLang(){
    if(gd_lang==="zh"){
      document.getElementById("bk").textContent="基轴体系";
      document.getElementById("bt").textContent="枢纽A · 索引";
      document.getElementById("bs").textContent="钻石分叉索引。从N/E/S/W开始。选择后只展开对应分支。";
    }else{
      document.getElementById("bk").textContent="CARDINAL AXIS";
      document.getElementById("bt").textContent="HUB A · Index";
      document.getElementById("bs").textContent="Diamond fork index. Start with N/E/S/W. Expand to branches only when selected.";
    }
  }
  setHeaderLang();

  function paintLang(){
    langEN.classList.toggle("on", gd_lang==="en");
    langZH.classList.toggle("on", gd_lang==="zh");
  }
  paintLang();

  viewInformal.onclick=()=>applyView("informal");
  viewFormal.onclick=()=>applyView("formal");
  viewBoth.onclick=()=>applyView("both");

  /* ===== Diamond Fork Tree =====
     Only N/E/S/W visible at start.
     Each primary reveals only its immediate branches.
  */
  const TREE = {
    N:{ label:{en:"N · DEFINITIONS",zh:"N · 定义"}, color:"#1F3A8A", children:["NE","NW"] },
    E:{ label:{en:"E · PRODUCTS",zh:"E · 产品"}, color:"#0EA5E9", children:["ENE","ESE"] },
    S:{ label:{en:"S · CONSTRAINTS",zh:"S · 约束"}, color:"#F59E0B", children:["SSE","SSW"] },
    W:{ label:{en:"W · CONTAINMENT",zh:"W · 隔离"}, color:"#7F1D1D", children:["WNW","WSW"] },

    /* Branch nodes */
    NE:{ label:{en:"NE",zh:"NE"}, color:"#2C3EAF", children:["ENE"] },
    NW:{ label:{en:"NW",zh:"NW"}, color:"#9333EA", children:["WNW"] },

    ENE:{ label:{en:"ENE",zh:"ENE"}, color:"#4B3FBF", children:[] },
    ESE:{ label:{en:"ESE",zh:"ESE"}, color:"#14B8A6", children:[] },

    SSE:{ label:{en:"SSE",zh:"SSE"}, color:"#22C55E", children:["ESE"] },
    SSW:{ label:{en:"SSW",zh:"SSW"}, color:"#EA580C", children:["WSW"] },

    WNW:{ label:{en:"WNW",zh:"WNW"}, color:"#9333EA", children:["NNW"] },
    WSW:{ label:{en:"WSW",zh:"WSW"}, color:"#DC2626", children:["SSW"] },

    /* Deep nodes */
    NNW:{ label:{en:"NNW",zh:"NNW"}, color:"#334155", children:[] }
  };

  /* ===== Project jump paths (FILL THESE) ===== */
  const JUMPS = {
    N:"#", E:"#", S:"#", W:"#",
    NE:"#", NW:"#",
    ENE:"#", ESE:"#",
    SSE:"#", SSW:"#",
    WNW:"#", WSW:"#",
    NNW:"#"
  };

  /* ===== Copy (1 paragraph per lens per node; bilingual) ===== */
  const COPY = {
    N:{
      informal:{en:"Collapse starts with loose words. North pins meaning before motion so scope stays honest under pressure and collaboration stays real.",zh:"崩塌始于词义松动。北在行动前钉住含义，使范围在压力下保持诚实，协作保持真实。"},
      formal:{en:"Scope precedes authority. Definitions constrain interpretation and verification cites fixed anchors so drift is detectable at first deviation.",zh:"范围先于权力。定义约束解释，核查引用固定锚点，使漂移在首次偏差时可检测。"}
    },
    E:{
      informal:{en:"People touch surfaces, not theories. East makes execution carry boundaries so adoption stays honest and scale stops gambling.",zh:"人触摸执行面而非理论。东让执行携带边界，使采纳诚实，规模不再赌博。"},
      formal:{en:"Execution inherits constraints. Products remain bounded, claims stay checkable, and verification routes remain explicit under scale.",zh:"执行继承约束。产品保持有界，主张可核查，核查路径在规模下仍显式。"}
    },
    S:{
      informal:{en:"Growth without gates guarantees failure. South enforces refusal before scale so pressure cannot bypass readiness.",zh:"无闸门的增长必然失败。南在规模化前执行拒绝，使压力无法绕过就绪。"},
      formal:{en:"Constraint precedes permission. Gates reject unsupported claims and enforce admissibility so expansion cannot outrun evidence.",zh:"约束先于许可。闸门拒绝无支撑主张并执行可采信，使扩张不能跑过证据。"}
    },
    W:{
      informal:{en:"Systems fail when events spread. West isolates fracture so damage stays local and recovery stays clean.",zh:"系统失败在于事件扩散。西隔离裂缝，使损伤局部化，恢复保持干净。"},
      formal:{en:"Containment remains architectural. Segmentation prevents cascade and returns preserve state so correction does not globalize failure.",zh:"隔离必须是架构。分段防级联，返回保状态，使修正不把失败全局化。"}
    },

    NE:{
      informal:{en:"NE is the clean bridge from meaning to expansion. Keep the meaning pinned while execution ramps or drift inflates claims.",zh:"NE是从含义到扩张的干净桥梁。含义要钉住，执行才可加速，否则漂移会膨胀主张。"},
      formal:{en:"NE preserves scope across growth. Translation remains bounded so expansion cannot mutate semantic anchors.",zh:"NE在增长中保范围。翻译保持有界，使扩张不能变异语义锚点。"}
    },
    NW:{
      informal:{en:"NW routes clarity into audit posture. It turns containment into feedback so meaning tightens instead of drifting.",zh:"NW把清晰路由到审计姿态。它把隔离变反馈，使含义收紧而不是漂移。"},
      formal:{en:"NW feeds definitions via audit. Corrections remain versioned and geometry remains stable under refinement.",zh:"NW通过审计反哺定义。修正版本化，几何在细化中保持稳定。"}
    },

    ENE:{
      informal:{en:"ENE drags the contract into the surface. Users stop guessing because boundaries show up where behavior lives.",zh:"ENE把契约拖进执行面。边界出现在行为所在处，用户无需猜测。"},
      formal:{en:"ENE compiles boundaries into interfaces. Claims lock to declared terms and acceptance criteria remain measurable.",zh:"ENE把边界编译进接口。主张锁定声明术语，验收标准保持可测。"}
    },
    ESE:{
      informal:{en:"ESE is power meeting gate. Readiness must lead or momentum becomes damage.",zh:"ESE是能力遇闸门。就绪必须领先，否则动量变损伤。"},
      formal:{en:"ESE binds scaling to prerequisites. Evidence governs exposure so rollout cannot outrun admissibility.",zh:"ESE把扩张绑定先决条件。证据治理曝光，使上线不能跑过可采信。"}
    },

    SSE:{
      informal:{en:"SSE turns ‘when’ into qualification. Deadlines stop deciding readiness; prerequisites do.",zh:"SSE把“何时”变成资格。就绪不由截止日决定，而由先决条件决定。"},
      formal:{en:"SSE enforces phase gates. Timing follows readiness so fragility cannot ship by schedule.",zh:"SSE执行阶段闸门。时间必须服从就绪，使脆弱不能按日程上线。"}
    },
    SSW:{
      informal:{en:"SSW couples refusal with isolation. Say no, segment the breach, and protect the rest.",zh:"SSW把拒绝与隔离耦合。先拒绝，分段破口，保护其余。"},
      formal:{en:"SSW pairs admissibility with containment. Boundary breaches segment immediately to prevent cascade.",zh:"SSW把可采信与隔离配对。破界即分段，防止级联。"}
    },

    WNW:{
      informal:{en:"WNW turns scars into clarity. Don’t rewrite history—version meaning and move forward cleaner.",zh:"WNW把伤痕变清晰。不改写历史——版本化含义，更干净地前进。"},
      formal:{en:"WNW routes audit feedback into definition tightening. Silent edits are prohibited; corrections remain explicit.",zh:"WNW把审计反馈路由到定义收紧。禁止静默改义；修正必须显式。"}
    },
    WSW:{
      informal:{en:"WSW keeps one crack from becoming everyone’s outage. Contain first, repair clean, continue.",zh:"WSW让一条裂缝不变全民停机。先隔离，干净修复，再继续。"},
      formal:{en:"WSW segments failure vectors. Partitioning prevents scale from amplifying single faults across domains.",zh:"WSW分段失败向量。分区防止规模放大单点故障到跨域。"}
    },

    NNW:{
      informal:{en:"NNW resets without semantic swap. Recovery must not smuggle new meaning into old claims.",zh:"NNW重置但不偷换概念。恢复不能把新含义偷渡进旧主张。"},
      formal:{en:"NNW preserves semantics during return. Re-entry maintains scope and changes remain auditable.",zh:"NNW在返回中保持语义。重入保持范围，变化保持可审计。"}
    }
  };

  /* ===== Build DOM ===== */
  function lensTitle(lens){
    return (lens==="formal")
      ? (gd_lang==="zh" ? "正式" : "Formal")
      : (gd_lang==="zh" ? "非正式" : "Informal");
  }

  function makeLensBlock(lens, obj){
    const b=document.createElement("div");
    b.className="lensBlock";
    b.setAttribute("data-lens", lens);

    const t=document.createElement("div");
    t.className="lensTitle";
    t.textContent = lensTitle(lens);

    const p=document.createElement("div");
    p.className="paragraph";
    p.textContent = (gd_lang==="zh") ? obj.zh : obj.en;

    b.appendChild(t);
    b.appendChild(p);
    return b;
  }

  function makeIndexLine(id){
    const line=document.createElement("div");
    line.className="indexLine";
    const lbl = (gd_lang==="zh") ? TREE[id].label.zh : TREE[id].label.en;
    line.append((gd_lang==="zh")
      ? ("索引：跳转到 "+lbl+" 对应项目。 ")
      : ("Index: jump to the project for "+lbl+". ")
    );
    const a=document.createElement("a");
    const target = JUMPS[id] || "#";
    a.href = (target === "#") ? "#" : (target + makeQS());
    a.textContent = (gd_lang==="zh") ? "跳转" : "Jump";
    line.appendChild(a);
    return line;
  }

  function makeNode(id){
    const info=TREE[id];

    const s=document.createElement("section");
    s.className="node";
    s.style.setProperty("--c", info.color || "#93C5FD");
    s.setAttribute("data-id", id);

    const h=document.createElement("div");
    h.className="nHead";
    h.innerHTML="<div class='nLeft'><div class='diamond'></div><div class='nLabel'>"+((gd_lang==="zh")?info.label.zh:info.label.en)+"</div></div><div>▸</div>";

    const b=document.createElement("div");
    b.className="nBody";

    // content blocks
    b.appendChild(makeLensBlock("informal", COPY[id].informal));
    b.appendChild(makeLensBlock("formal", COPY[id].formal));
    b.appendChild(makeIndexLine(id));

    // children (fork)
    if(info.children && info.children.length){
      const stack=document.createElement("div");
      stack.className="childStack";
      info.children.forEach(child=>{
        stack.appendChild(makeNode(child));
      });
      b.appendChild(stack);
    }

    h.addEventListener("click",()=>{
      s.classList.toggle("open");
      localStorage.setItem("hub_active_node", id);
      recomputeHeights();
    });

    s.appendChild(h);
    s.appendChild(b);
    return s;
  }

  function render(){
    root.innerHTML="";
    ["N","E","S","W"].forEach(k=>root.appendChild(makeNode(k)));
    recomputeHeights();
  }

  /* ===== Russian Doll scroll metric ===== */
  function recomputeHeights(){
    const dockH = dock ? dock.getBoundingClientRect().height : 92;
    document.documentElement.style.setProperty("--dockH", dockH + "px");

    const brandH = brand ? brand.getBoundingClientRect().height : 0;
    const viewportH = window.innerHeight || 800;
    const avail = Math.max(220, viewportH - brandH - dockH - 48);

    // cap every open node body (nested)
    root.querySelectorAll(".node.open .nBody").forEach(el=>{
      el.style.maxHeight = avail + "px";
    });
  }
  window.addEventListener("resize", recomputeHeights);

  /* ===== Language switching (safe rebuild; preserves open state) ===== */
  function snapshotOpen(){
    const openIds=[];
    root.querySelectorAll(".node.open").forEach(n=>openIds.push(n.getAttribute("data-id")));
    return openIds;
  }
  function restoreOpen(ids){
    const set=new Set(ids);
    root.querySelectorAll(".node").forEach(n=>{
      const id=n.getAttribute("data-id");
      if(set.has(id)) n.classList.add("open");
    });
    recomputeHeights();
  }

  function setLang(next){
    const openIds=snapshotOpen();
    gd_lang=next;
    try{ localStorage.setItem("gd_lang", gd_lang); }catch(e){}
    document.documentElement.lang = (gd_lang==="zh") ? "zh" : "en";
    paintLang();
    setHeaderLang();
    render();
    restoreOpen(openIds);
  }

  function setHeaderLang(){
    if(gd_lang==="zh"){
      document.getElementById("bk").textContent="基轴体系";
      document.getElementById("bt").textContent="枢纽A · 索引";
      document.getElementById("bs").textContent="钻石分叉索引。从N/E/S/W开始。选择后只展开对应分支。";
    }else{
      document.getElementById("bk").textContent="CARDINAL AXIS";
      document.getElementById("bt").textContent="HUB A · Index";
      document.getElementById("bs").textContent="Diamond fork index. Start with N/E/S/W. Expand to branches only when selected.";
    }
  }

  function paintLang(){
    langEN.classList.toggle("on", gd_lang==="en");
    langZH.classList.toggle("on", gd_lang==="zh");
  }

  langEN.onclick=()=>setLang("en");
  langZH.onclick=()=>setLang("zh");

  /* ===== Bottom dock wiring ===== */
  document.getElementById("navBack").onclick=()=>history.back();
  document.getElementById("navForward").onclick=()=>history.forward();
  document.getElementById("navHub").onclick=()=>nav("/home/");
  document.getElementById("navExplore").onclick=()=>nav("/explore/");
  document.getElementById("navProducts").onclick=()=>nav("/products/");
  document.getElementById("navLaws").onclick=()=>nav("/laws/");
  document.getElementById("navGauges").onclick=()=>nav("/gauges/");
  document.getElementById("navTop").onclick=()=>window.scrollTo({top:0,behavior:"smooth"});
  document.getElementById("navJump").onclick=()=>{
    const id = localStorage.getItem("hub_active_node") || "N";
    const target = JUMPS[id] || "#";
    if(target === "#") return;
    location.href = target + makeQS();
  };

  /* ===== Init ===== */
  paintLang();
  setHeaderLang();
  render();

})();
</script>

</body>
</html>
